#!/usr/bin/env python3
"""\nKV-Cache Manager - User-Space Cache Management for LLM Inference\n\nManages transformer key-value caches as first-class system resources.\nPOSIX shared memory pools with multiple eviction policies.\n\nUsage:\n    cortex cache create llama-cache --size 16G --tier cpu\n    cortex cache status llama-cache\n    cortex cache persist llama-cache\n    cortex cache restore llama-cache\n    cortex cache evict llama-cache --percent 25\n\nAuthor: Yair Siegel\nBounty: cortexlinux/cortex#221\n"""\n\nimport os\nimport sys\nimport json\nimport mmap\nimport struct\nimport hashlib\nimport argparse\nimport threading\nfrom pathlib import Path\nfrom dataclasses import dataclass, field, asdict\nfrom typing import Dict, List, Optional, Tuple, Any\nfrom datetime import datetime, timezone\nfrom enum import Enum\nfrom collections import OrderedDict\nimport time\n\n\n# =============================================================================\n# CONSTANTS\n# =============================================================================\n\nCACHE_MAGIC = b'KVCH'  # Magic bytes for cache header\nCACHE_VERSION = 1\nBLOCK_SIZE = 4096  # 4KB blocks\nHEADER_SIZE = 4096  # Header block\nBITMAP_SIZE = 4096  # Free list bitmap\n\n\n# =============================================================================\n# EVICTION POLICIES\n# =============================================================================\n\nclass EvictionPolicy(Enum):\n    LRU = \"lru\"      # Least Recently Used\n    LFU = \"lfu\"      # Least Frequently Used\n    FIFO = \"fifo\"    # First In First Out\n    PRIORITY = \"priority\"  # Priority-based (user-defined)\n\n\n# =============================================================================\n# CACHE ENTRY\n# =============================================================================\n\n@dataclass\nclass CacheEntry:\n    \"\"\"Metadata for a cached KV tensor.\"\"\"\n    key: str\n    prefix_hash: str  # Hash of prompt prefix for sharing\n    offset: int       # Byte offset in pool\n    size: int         # Size in bytes\n    created_at: float\n    last_accessed: float\n    access_count: int = 0\n    priority: int = 0  # Higher = more important\n    sequence_length: int = 0\n    layer_index: int = 0\n\n    def to_dict(self) -> Dict:\n        return asdict(self)\n\n    @classmethod\n    def from_dict(cls, data: Dict) -> 'CacheEntry':\n        return cls(**data)\n\n\n# =============================================================================\n# CACHE POOL CONFIGURATION\n# =============================================================================\n\n@dataclass\nclass CachePoolConfig:\n    \"\"\"Configuration for a KV-cache pool.\"\"\"\n    name: str\n    size_bytes: int\n    tier: str = \"cpu\"  # cpu, gpu, nvme\n    eviction_policy: str = \"lru\"\n    max_entries: int = 10000\n    persist_path: Optional[str] = None\n    created_at: str = field(default_factory=lambda: datetime.now(timezone.utc).isoformat())\n\n    def to_dict(self) -> Dict:\n        return asdict(self)\n\n    @classmethod\n    def from_dict(cls, data: Dict) -> 'CachePoolConfig':\n        return cls(**{k: v for k, v in data.items() if k in cls.__dataclass_fields__})\n\n\n# =============================================================================\n# BITMAP ALLOCATOR\n# =============================================================================\n\nclass BitmapAllocator:\n    \"\"\"\n    Thread-safe bitmap-based block allocator.\n\n    Each bit represents one block. 1 = allocated, 0 = free.\n    \"\"\"\n\n    def __init__(self, num_blocks: int):\n        self.num_blocks = num_blocks\n        self.bitmap_size = (num_blocks + 7) // 8\n        self.bitmap = bytearray(self.bitmap_size)\n        self.lock = threading.Lock()\n        self.allocated_count = 0\n\n    def allocate(self, num_blocks: int) -> Optional[int]:\n        \"\"\"\n        Allocate contiguous blocks. Returns starting block index or None.\n        \"\"\"\n        with self.lock:\n            # Simple first-fit algorithm\n            consecutive = 0\n            start_block = 0\n\n            for i in range(self.num_blocks):\n                if self._is_free(i):\n                    if consecutive == 0:\n                        start_block = i\n                    consecutive += 1\n                    if consecutive == num_blocks:\n                        # Found enough space, mark as allocated\n                        for j in range(start_block, start_block + num_blocks):\n                            self._set_allocated(j)\n                        self.allocated_count += num_blocks\n                        return start_block\n                else:\n                    consecutive = 0\n\n            return None\n\n    def free(self, start_block: int, num_blocks: int):\n        \"\"\"Free allocated blocks.\"\"\"\n        with self.lock:\n            for i in range(start_block, start_block + num_blocks):\n                self._set_free(i)\n            self.allocated_count -= num_blocks\n\n    def _is_free(self, block: int) -> bool:\n        byte_idx = block // 8\n        bit_idx = block % 8\n        return (self.bitmap[byte_idx] & (1 << bit_idx)) == 0\n\n    def _set_allocated(self, block: int):\n        byte_idx = block // 8\n        bit_idx = block % 8\n        self.bitmap[byte_idx] |= (1 << bit_idx)\n\n    def _set_free(self, block: int):\n        byte_idx = block // 8\n        bit_idx = block % 8\n        self.bitmap[byte_idx] &= ~(1 << bit_idx)\n\n    def get_usage(self) -> Tuple[int, int]:\n        \"\"\"Returns (allocated_blocks, total_blocks).\"\"\"\n        return (self.allocated_count, self.num_blocks)\n\n    def to_bytes(self) -> bytes:\n        \"\"\"Serialize bitmap for persistence.\"\"\"\n        return bytes(self.bitmap)\n\n    def from_bytes(self, data: bytes):\n        \"\"\"Restore bitmap from persistence.\"\"\"\n        self.bitmap = bytearray(data[:self.bitmap_size])\n        # Recount allocated\n        self.allocated_count = sum(\n            bin(b).count('1') for b in self.bitmap\n        )\n\n\n# =============================================================================\n# EVICTION MANAGER\n# =============================================================================\n\nclass EvictionManager:\n    \"\"\"Manages cache eviction based on configured policy.\"\"\"\n\n    def __init__(self, policy: EvictionPolicy):\n        self.policy = policy\n        self.entries: Dict[str, CacheEntry] = {}\n        self.access_order: OrderedDict = OrderedDict()  # For LRU\n        self.lock = threading.Lock()\n\n    def add(self, entry: CacheEntry):\n        \"\"\"Add entry to eviction tracking.\"\"\"\n        with self.lock:\n            self.entries[entry.key] = entry\n            if self.policy == EvictionPolicy.LRU:\n                self.access_order[entry.key] = entry.last_accessed\n            elif self.policy == EvictionPolicy.FIFO:\n                self.access_order[entry.key] = entry.created_at\n\n    def access(self, key: str):\n        \"\"\"Record access (for LRU/LFU).\"\"\"\n        with self.lock:\n            if key in self.entries:\n                entry = self.entries[key]\n                entry.last_accessed = time.time()\n                entry.access_count += 1\n\n                if self.policy == EvictionPolicy.LRU:\n                    # Move to end of order\n                    self.access_order.move_to_end(key)\n\n    def remove(self, key: str):\n        \"\"\"Remove entry from tracking.\"\"\"\n        with self.lock:\n            if key in self.entries:\n                del self.entries[key]\n            if key in self.access_order:\n                del self.access_order[key]\n\n    def get_eviction_candidates(self, count: int) -> List[str]:\n        \"\"\"Get keys to evict based on policy.\"\"\"\n        with self.lock:\n            if self.policy == EvictionPolicy.LRU:\n                # Oldest accessed first\n                return list(self.access_order.keys())[:count]\n\n            elif self.policy == EvictionPolicy.LFU:\n                # Least accessed first\n                sorted_entries = sorted(\n                    self.entries.items(),\n                    key=lambda x: x[1].access_count\n                )\n                return [k for k, v in sorted_entries[:count]]\n\n            elif self.policy == EvictionPolicy.FIFO:\n                # First created first\n                return list(self.access_order.keys())[:count]\n\n            elif self.policy == EvictionPolicy.PRIORITY:\n                # Lowest priority first\n                sorted_entries = sorted(\n                    self.entries.items(),\n                    key=lambda x: x[1].priority\n                )\n                return [k for k, v in sorted_entries[:count]]\n\n            return []\n\n    def get_all_entries(self) -> List[CacheEntry]:\n        \"\"\"Get all tracked entries.\"\"\"\n        with self.lock:\n            return list(self.entries.values())\n\n\n# =============================================================================\n# KV CACHE POOL\n# =============================================================================\n\nclass KVCachePool:\n    \"\"\"\n    POSIX shared memory pool for KV-cache tensors.\n\n    Memory Layout:\n    ┌──────────────────┐\n    │ Header (4KB)     │ Magic, version, config\n    ├──────────────────┤\n    │ Bitmap (4KB)     │ Free list\n    ├──────────────────┤\n    │ Data Region      │ KV tensors\n    └──────────────────┘\n    \"\"\"\n\n    def __init__(self, config: CachePoolConfig, create: bool = True):\n        self.config = config\n        self.name = config.name\n        self.size = config.size_bytes\n\n        # Calculate blocks\n        self.data_offset = HEADER_SIZE + BITMAP_SIZE\n        self.data_size = self.size - self.data_offset\n        self.num_blocks = self.data_size // BLOCK_SIZE\n\n        # Initialize allocator and eviction manager\n        self.allocator = BitmapAllocator(self.num_blocks)\n        self.eviction = EvictionManager(EvictionPolicy(config.eviction_policy))\n\n        # Entry index\n        self.entries: Dict[str, CacheEntry] = {}\n        self.prefix_index: Dict[str, List[str]] = {}  # prefix_hash -> keys\n        self.lock = threading.Lock()\n\n        # Memory mapping (simulated for portability)\n        self._data = bytearray(self.data_size)\n\n        if create:\n            self._init_header()\n\n    def _init_header(self):\n        \"\"\"Initialize pool header.\"\"\"\n        # In real implementation, this would write to shared memory\n        pass\n\n    def allocate(self, key: str, size: int, prefix_hash: str = \"\",\n                 priority: int = 0, sequence_length: int = 0,\n                 layer_index: int = 0) -> Optional[CacheEntry]:\n        \"\"\"Allocate space for a KV cache entry.\"\"\"\n        num_blocks = (size + BLOCK_SIZE - 1) // BLOCK_SIZE\n\n        with self.lock:\n            # Try to allocate\n            start_block = self.allocator.allocate(num_blocks)\n\n            if start_block is None:\n                # Need to evict\n                freed = self._evict_for_space(num_blocks)\n                if freed:\n                    start_block = self.allocator.allocate(num_blocks)\n\n            if start_block is None:\n                return None\n\n            # Create entry\n            now = time.time()\n            entry = CacheEntry(\n                key=key,\n                prefix_hash=prefix_hash or self._compute_prefix_hash(key),\n                offset=self.data_offset + (start_block * BLOCK_SIZE),\n                size=size,\n                created_at=now,\n                last_accessed=now,\n                priority=priority,\n                sequence_length=sequence_length,\n                layer_index=layer_index,\n            )\n\n            # Track entry\n            self.entries[key] = entry\n            self.eviction.add(entry)\n\n            # Update prefix index\n            if entry.prefix_hash not in self.prefix_index:\n                self.prefix_index[entry.prefix_hash] = []\n            self.prefix_index[entry.prefix_hash].append(key)\n\n            return entry\n\n    def get(self, key: str) -> Optional[bytes]:\n        \"\"\"Get cached data by key.\"\"\"\n        with self.lock:\n            entry = self.entries.get(key)\n            if entry is None:\n                return None\n\n            self.eviction.access(key)\n\n            # Read from data region\n            start = entry.offset - self.data_offset\n            return bytes(self._data[start:start + entry.size])\n\n    def put(self, key: str, data: bytes, **kwargs) -> bool:\n        \"\"\"Store data in cache.\"\"\"\n        entry = self.allocate(key, len(data), **kwargs)\n        if entry is None:\n            return False\n\n        # Write to data region\n        start = entry.offset - self.data_offset\n        self._data[start:start + len(data)] = data\n        return True\n\n    def delete(self, key: str) -> bool:\n        \"\"\"Delete entry from cache.\"\"\"\n        with self.lock:\n            entry = self.entries.get(key)\n            if entry is None:\n                return False\n\n            # Free blocks\n            start_block = (entry.offset - self.data_offset) // BLOCK_SIZE\n            num_blocks = (entry.size + BLOCK_SIZE - 1) // BLOCK_SIZE\n            self.allocator.free(start_block, num_blocks)\n\n            # Remove from tracking\n            del self.entries[key]\n            self.eviction.remove(key)\n\n            # Update prefix index\n            if entry.prefix_hash in self.prefix_index:\n                self.prefix_index[entry.prefix_hash].remove(key)\n                if not self.prefix_index[entry.prefix_hash]:\n                    del self.prefix_index[entry.prefix_hash]\n\n            return True\n\n    def find_by_prefix(self, prefix_hash: str) -> List[CacheEntry]:\n        \"\"\"Find cache entries by prefix hash (for sharing).\"\"\"\n        with self.lock:\n            keys = self.prefix_index.get(prefix_hash, [])\n            return [self.entries[k] for k in keys if k in self.entries]\n\n    def evict(self, percent: float) -> int:\n        \"\"\"Evict a percentage of entries.\"\"\"\n        count = int(len(self.entries) * (percent / 100))\n        return self._evict_entries(count)\n\n    def _evict_for_space(self, blocks_needed: int) -> bool:\n        \"\"\"Evict entries to free space.\"\"\"\n        allocated, total = self.allocator.get_usage()\n        free = total - allocated\n\n        if free >= blocks_needed:\n            return True\n\n        # Evict until we have space\n        candidates = self.eviction.get_eviction_candidates(len(self.entries))\n        freed = 0\n\n        for key in candidates:\n            entry = self.entries.get(key)\n            if entry:\n                entry_blocks = (entry.size + BLOCK_SIZE - 1) // BLOCK_SIZE\n                self.delete(key)\n                freed += entry_blocks\n\n                if freed >= blocks_needed:\n                    return True\n\n        return freed >= blocks_needed\n\n    def _evict_entries(self, count: int) -> int:\n        \"\"\"Evict specified number of entries.\"\"\"\n        candidates = self.eviction.get_eviction_candidates(count)\n        evicted = 0\n\n        for key in candidates:\n            if self.delete(key):\n                evicted += 1\n\n        return evicted\n\n    def _compute_prefix_hash(self, key: str) -> str:\n        \"\"\"Compute prefix hash for cache sharing.\"\"\"\n        # Simple hash - in practice would hash actual prompt prefix\n        return hashlib.sha256(key.encode()[:64]).hexdigest()[:16]\n\n    def get_stats(self) -> Dict:\n        \"\"\"Get pool statistics.\"\"\"\n        allocated, total = self.allocator.get_usage()\n        return {\n            \"name\": self.name,\n            \"size_bytes\": self.size,\n            \"data_size_bytes\": self.data_size,\n            \"block_size\": BLOCK_SIZE,\n            \"total_blocks\": total,\n            \"allocated_blocks\": allocated,\n            \"free_blocks\": total - allocated,\n            \"utilization_percent\": (allocated / total * 100) if total > 0 else 0,\n            \"entry_count\": len(self.entries),\n            \"policy\": self.config.eviction_policy,\n        }\n\n    def persist(self, path: str) -> bool:\n        \"\"\"Persist pool to disk.\"\"\"\n        persist_path = Path(path)\n        persist_path.parent.mkdir(parents=True, exist_ok=True)\n\n        with self.lock:\n            try:\n                data = {\n                    \"config\": self.config.to_dict(),\n                    \"entries\": {k: v.to_dict() for k, v in self.entries.items()},\n                    \"bitmap\": self.allocator.to_bytes().hex(),\n                    \"data\": self._data.hex(),\n                }\n                persist_path.write_text(json.dumps(data))\n                return True\n            except Exception as e:\n                print(f\"[ERROR] Failed to persist: {e}\")\n                return False\n\n    @classmethod\n    def restore(cls, path: str) -> Optional['KVCachePool']:\n        \"\"\"Restore pool from disk.\"\"\"\n        persist_path = Path(path)\n        if not persist_path.exists():\n            return None\n\n        try:\n            data = json.loads(persist_path.read_text())\n            config = CachePoolConfig.from_dict(data[\"config\"])\n            pool = cls(config, create=False)\n\n            # Restore bitmap\n            pool.allocator.from_bytes(bytes.fromhex(data[\"bitmap\"]))\n\n            # Restore data\n            pool._data = bytearray(bytes.fromhex(data[\"data\"]))\n\n            # Restore entries\n            for key, entry_data in data[\"entries\"].items():\n                entry = CacheEntry.from_dict(entry_data)\n                pool.entries[key] = entry\n                pool.eviction.add(entry)\n\n                if entry.prefix_hash not in pool.prefix_index:\n                    pool.prefix_index[entry.prefix_hash] = []\n                pool.prefix_index[entry.prefix_hash].append(key)\n\n            return pool\n        except Exception as e:\n            print(f\"[ERROR] Failed to restore: {e}\")\n            return None\n\n\n# =============================================================================\n# CACHE STORE\n# =============================================================================\n\nclass CacheStore:\n    \"\"\"Manages multiple KV-cache pools.\"\"\"\n\n    def __init__(self, store_path: str = None):\n        if store_path is None:\n            store_path = os.path.expanduser(\"~/.config/cortex/kv_cache\")\n        self.store_path = Path(store_path)\n        self.store_path.mkdir(parents=True, exist_ok=True)\n        self.pools: Dict[str, KVCachePool] = {}\n\n    def create(self, config: CachePoolConfig) -> KVCachePool:\n        \"\"\"Create a new cache pool.\"\"\"\n        pool = KVCachePool(config)\n        self.pools[config.name] = pool\n        self._save_config(config)\n        return pool\n\n    def get(self, name: str) -> Optional[KVCachePool]:\n        \"\"\"Get pool by name.\"\"\"\n        if name in self.pools:\n            return self.pools[name]\n\n        # Try to load from disk\n        config = self._load_config(name)\n        if config:\n            pool = KVCachePool(config)\n            self.pools[name] = pool\n            return pool\n\n        return None\n\n    def delete(self, name: str) -> bool:\n        \"\"\"Delete a pool.\"\"\"\n        if name in self.pools:\n            del self.pools[name]\n\n        config_path = self.store_path / f\"{name}.json\"\n        if config_path.exists():\n            config_path.unlink()\n            return True\n        return False\n\n    def list(self) -> List[str]:\n        \"\"\"List all pools.\"\"\"\n        return [p.stem for p in self.store_path.glob(\"*.json\")]\n\n    def _save_config(self, config: CachePoolConfig):\n        \"\"\"Save pool configuration.\"\"\"\n        config_path = self.store_path / f\"{config.name}.json\"\n        config_path.write_text(json.dumps(config.to_dict(), indent=2))\n\n    def _load_config(self, name: str) -> Optional[CachePoolConfig]:\n        \"\"\"Load pool configuration.\"\"\"\n        config_path = self.store_path / f\"{name}.json\"\n        if config_path.exists():\n            return CachePoolConfig.from_dict(json.loads(config_path.read_text()))\n        return None\n\n\n# =============================================================================\n# CLI\n# =============================================================================\n\ndef parse_size(size_str: str) -> int:\n    \"\"\"Parse size string like '16G' to bytes.\"\"\"\n    size_str = size_str.upper().strip()\n    multipliers = {\n        'K': 1024,\n        'M': 1024 ** 2,\n        'G': 1024 ** 3,\n        'T': 1024 ** 4,\n    }\n\n    if size_str[-1] in multipliers:\n        return int(float(size_str[:-1]) * multipliers[size_str[-1]])\n    return int(size_str)\n\n\ndef format_size(size_bytes: int) -> str:\n    \"\"\"Format bytes to human readable.\"\"\"\n    for unit in ['B', 'KB', 'MB', 'GB', 'TB']:\n        if size_bytes < 1024:\n            return f\"{size_bytes:.1f} {unit}\"\n        size_bytes /= 1024\n    return f\"{size_bytes:.1f} PB\"\n\n\nclass KVCacheCLI:\n    \"\"\"CLI for cortex cache command.\"\"\"\n\n    def __init__(self):\n        self.store = CacheStore()\n\n    def create(self, args):\n        \"\"\"Create a new cache pool.\"\"\"\n        size = parse_size(args.size)\n\n        config = CachePoolConfig(\n            name=args.name,\n            size_bytes=size,\n            tier=args.tier,\n            eviction_policy=args.policy,\n        )\n\n        pool = self.store.create(config)\n        stats = pool.get_stats()\n\n        print(f\"Created cache pool '{args.name}'\")\n        print(f\"  Size: {format_size(size)}\")\n        print(f\"  Tier: {args.tier}\")\n        print(f\"  Policy: {args.policy}\")\n        print(f\"  Blocks: {stats['total_blocks']}\")\n        return 0\n\n    def status(self, args):\n        \"\"\"Show cache status.\"\"\"\n        if args.name:\n            pool = self.store.get(args.name)\n            if not pool:\n                print(f\"Cache '{args.name}' not found\")\n                return 1\n\n            stats = pool.get_stats()\n            print(f\"Cache: {stats['name']}\")\n            print(f\"  Size: {format_size(stats['size_bytes'])}\")\n            print(f\"  Used: {format_size(stats['allocated_blocks'] * BLOCK_SIZE)}\")\n            print(f\"  Free: {format_size(stats['free_blocks'] * BLOCK_SIZE)}\")\n            print(f\"  Utilization: {stats['utilization_percent']:.1f}%\")\n            print(f\"  Entries: {stats['entry_count']}\")\n            print(f\"  Policy: {stats['policy']}\")\n        else:\n            pools = self.store.list()\n            if not pools:\n                print(\"No cache pools\")\n                return 0\n\n            print(\"Cache pools:\")\n            for name in pools:\n                pool = self.store.get(name)\n                if pool:\n                    stats = pool.get_stats()\n                    print(f\"  {name}: {format_size(stats['size_bytes'])} ({stats['utilization_percent']:.1f}% used)\")\n\n        return 0\n\n    def persist(self, args):\n        \"\"\"Persist cache to disk.\"\"\"\n        pool = self.store.get(args.name)\n        if not pool:\n            print(f\"Cache '{args.name}' not found\")\n            return 1\n\n        persist_path = args.path or f\"/tmp/cortex_cache_{args.name}.dat\"\n        if pool.persist(persist_path):\n            print(f\"Persisted cache '{args.name}' to {persist_path}\")\n            return 0\n        return 1\n\n    def restore(self, args):\n        \"\"\"Restore cache from disk.\"\"\"\n        persist_path = args.path\n        if not Path(persist_path).exists():\n            print(f\"File not found: {persist_path}\")\n            return 1\n\n        pool = KVCachePool.restore(persist_path)\n        if pool:\n            self.store.pools[pool.name] = pool\n            print(f\"Restored cache '{pool.name}' from {persist_path}\")\n            return 0\n        return 1\n\n    def evict(self, args):\n        \"\"\"Evict entries from cache.\"\"\"\n        pool = self.store.get(args.name)\n        if not pool:\n            print(f\"Cache '{args.name}' not found\")\n            return 1\n\n        evicted = pool.evict(args.percent)\n        print(f\"Evicted {evicted} entries from '{args.name}'\")\n        return 0\n\n    def delete(self, args):\n        \"\"\"Delete a cache pool.\"\"\"\n        if self.store.delete(args.name):\n            print(f\"Deleted cache '{args.name}'\")\n            return 0\n        print(f\"Cache '{args.name}' not found\")\n        return 1\n\n    def policies(self, args):\n        \"\"\"List available eviction policies.\"\"\"\n        print(\"Available eviction policies:\")\n        for policy in EvictionPolicy:\n            desc = {\n                \"lru\": \"Least Recently Used - evict oldest accessed\",\n                \"lfu\": \"Least Frequently Used - evict least accessed\",\n                \"fifo\": \"First In First Out - evict oldest created\",\n                \"priority\": \"Priority-based - evict lowest priority\",\n            }\n            print(f\"  {policy.value}: {desc[policy.value]}\")\n        return 0\n\n\ndef main():\n    parser = argparse.ArgumentParser(\n        description=\"KV-Cache Manager\",\n        prog=\"cortex cache\"\n    )\n    subparsers = parser.add_subparsers(dest=\"command\", required=True)\n\n    # create\n    create_parser = subparsers.add_parser(\"create\", help=\"Create cache pool\")\n    create_parser.add_argument(\"name\", help=\"Pool name\")\n    create_parser.add_argument(\"--size\", \"-s\", required=True, help=\"Pool size (e.g., 16G)\")\n    create_parser.add_argument(\"--tier\", \"-t\", default=\"cpu\",\n                              choices=[\"cpu\", \"gpu\", \"nvme\"], help=\"Memory tier\")\n    create_parser.add_argument(\"--policy\", \"-p\", default=\"lru\",\n                              choices=[p.value for p in EvictionPolicy],\n                              help=\"Eviction policy\")\n\n    # status\n    status_parser = subparsers.add_parser(\"status\", help=\"Show status\")\n    status_parser.add_argument(\"name\", nargs=\"?\", help=\"Pool name\")\n\n    # persist\n    persist_parser = subparsers.add_parser(\"persist\", help=\"Persist to disk\")\n    persist_parser.add_argument(\"name\", help=\"Pool name\")\n    persist_parser.add_argument(\"--path\", help=\"Persistence path\")\n\n    # restore\n    restore_parser = subparsers.add_parser(\"restore\", help=\"Restore from disk\")\n    restore_parser.add_argument(\"path\", help=\"Persistence path\")\n\n    # evict\n    evict_parser = subparsers.add_parser(\"evict\", help=\"Evict entries\")\n    evict_parser.add_argument(\"name\", help=\"Pool name\")\n    evict_parser.add_argument(\"--percent\", \"-p\", type=float, default=25,\n                             help=\"Percent to evict\")\n\n    # delete\n    delete_parser = subparsers.add_parser(\"delete\", help=\"Delete pool\")\n    delete_parser.add_argument(\"name\", help=\"Pool name\")\n\n    # policies\n    subparsers.add_parser(\"policies\", help=\"List eviction policies\")\n\n    args = parser.parse_args()\n    cli = KVCacheCLI()\n\n    commands = {\n        \"create\": cli.create,\n        \"status\": cli.status,\n        \"persist\": cli.persist,\n        \"restore\": cli.restore,\n        \"evict\": cli.evict,\n        \"delete\": cli.delete,\n        \"policies\": cli.policies,\n    }\n\n    return commands[args.command](args)\n\n\nif __name__ == \"__main__\":\n    sys.exit(main() or 0)\n