#!/usr/bin/env python3
"""
Tests for Vulnerability Scanner Module
"""

import os
import tempfile
import unittest
from datetime import datetime
from unittest.mock import MagicMock, patch

from cortex.vulnerability_scanner import (
    ScanResult,
    Severity,
    Vulnerability,
    VulnerabilityScanner,
)


class TestSeverityEnum(unittest.TestCase):
    """Test cases for Severity enum"""

    def test_severity_values(self):
        """Test severity enum has correct values"""
        self.assertEqual(Severity.CRITICAL.value, "critical")
        self.assertEqual(Severity.HIGH.value, "high")
        self.assertEqual(Severity.MEDIUM.value, "medium")
        self.assertEqual(Severity.LOW.value, "low")
        self.assertEqual(Severity.UNKNOWN.value, "unknown")

    def test_severity_from_string(self):
        """Test creating severity from string"""
        self.assertEqual(Severity("critical"), Severity.CRITICAL)
        self.assertEqual(Severity("high"), Severity.HIGH)


class TestVulnerability(unittest.TestCase):
    """Test cases for Vulnerability dataclass"""

    def test_vulnerability_creation(self):
        """Test creating vulnerability object"""
        vuln = Vulnerability(
            cve_id="CVE-2023-12345",
            package_name="nginx",
            installed_version="1.18.0",
            affected_versions="< 1.20.0",
            severity=Severity.HIGH,
            description="Test vulnerability",
        )

        self.assertEqual(vuln.cve_id, "CVE-2023-12345")
        self.assertEqual(vuln.package_name, "nginx")
        self.assertEqual(vuln.severity, Severity.HIGH)
        self.assertIsNotNone(vuln.references)
        self.assertEqual(len(vuln.references), 0)

    def test_vulnerability_with_optional_fields(self):
        """Test vulnerability with optional fields"""
        vuln = Vulnerability(
            cve_id="CVE-2023-12345",
            package_name="nginx",
            installed_version="1.18.0",
            affected_versions="< 1.20.0",
            severity=Severity.CRITICAL,
            description="Test vulnerability",
            fixed_version="1.20.0",
            cvss_score=9.8,
            source="nvd",
            references=["https://example.com"],
        )

        self.assertEqual(vuln.fixed_version, "1.20.0")
        self.assertEqual(vuln.cvss_score, 9.8)
        self.assertEqual(vuln.source, "nvd")
        self.assertEqual(len(vuln.references), 1)


class TestScanResult(unittest.TestCase):
    """Test cases for ScanResult dataclass"""

    def test_scan_result_creation(self):
        """Test creating scan result object"""
        result = ScanResult(
            scan_id="scan_123",
            timestamp="2024-01-01T00:00:00",
            total_packages_scanned=100,
            vulnerabilities_found=5,
            critical_count=1,
            high_count=2,
            medium_count=1,
            low_count=1,
            vulnerabilities=[],
            scan_duration_seconds=10.5,
        )

        self.assertEqual(result.scan_id, "scan_123")
        self.assertEqual(result.vulnerabilities_found, 5)
        self.assertEqual(result.critical_count, 1)
        self.assertIsNotNone(result.errors)


class TestVulnerabilityScanner(unittest.TestCase):
    """Test cases for VulnerabilityScanner"""

    def setUp(self):
        """Set up test fixtures"""
        self.temp_db = tempfile.NamedTemporaryFile(delete=False, suffix=".db")
        self.temp_db.close()
        self.scanner = VulnerabilityScanner(db_path=self.temp_db.name)

    def tearDown(self):
        """Clean up temporary files"""
        if os.path.exists(self.temp_db.name):
            os.unlink(self.temp_db.name)

    def test_database_initialization(self):
        """Test database is created properly"""
        self.assertTrue(os.path.exists(self.temp_db.name))

    def test_vulnerability_to_dict(self):
        """Test converting vulnerability to dict"""
        vuln = Vulnerability(
            cve_id="CVE-2023-12345",
            package_name="nginx",
            installed_version="1.18.0",
            affected_versions="< 1.20.0",
            severity=Severity.HIGH,
            description="Test vulnerability",
            cvss_score=7.5,
        )

        vuln_dict = self.scanner._vulnerability_to_dict(vuln)

        self.assertEqual(vuln_dict["cve_id"], "CVE-2023-12345")
        self.assertEqual(vuln_dict["severity"], "high")  # Should be string, not enum
        self.assertEqual(vuln_dict["cvss_score"], 7.5)

    def test_dict_to_vulnerability(self):
        """Test converting dict to vulnerability"""
        vuln_dict = {
            "cve_id": "CVE-2023-12345",
            "package_name": "nginx",
            "installed_version": "1.18.0",
            "affected_versions": "< 1.20.0",
            "severity": "high",
            "description": "Test vulnerability",
        }

        vuln = self.scanner._dict_to_vulnerability(vuln_dict)

        self.assertEqual(vuln.cve_id, "CVE-2023-12345")
        self.assertEqual(vuln.severity, Severity.HIGH)

    def test_dict_to_vulnerability_unknown_severity(self):
        """Test converting dict with unknown severity"""
        vuln_dict = {
            "cve_id": "CVE-2023-12345",
            "package_name": "test",
            "installed_version": "1.0",
            "affected_versions": "all",
            "severity": "invalid_severity",
            "description": "Test",
        }

        vuln = self.scanner._dict_to_vulnerability(vuln_dict)

        self.assertEqual(vuln.severity, Severity.UNKNOWN)

    def test_parse_cvss_vector_critical(self):
        """Test parsing CVSS vector for critical severity"""
        # CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H = ~9.8 (Critical)
        vector = "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
        score = self.scanner._parse_cvss_vector(vector)

        self.assertIsNotNone(score)
        self.assertGreaterEqual(score, 9.0)

    def test_parse_cvss_vector_low(self):
        """Test parsing CVSS vector for low severity"""
        # CVSS:3.1/AV:P/AC:H/PR:H/UI:R/S:U/C:N/I:N/A:L = low
        vector = "CVSS:3.1/AV:P/AC:H/PR:H/UI:R/S:U/C:N/I:N/A:L"
        score = self.scanner._parse_cvss_vector(vector)

        self.assertIsNotNone(score)
        self.assertLess(score, 4.0)

    def test_parse_cvss_vector_invalid(self):
        """Test parsing invalid CVSS vector"""
        score = self.scanner._parse_cvss_vector("not a cvss vector")
        self.assertIsNone(score)

        score = self.scanner._parse_cvss_vector("")
        self.assertIsNone(score)

        score = self.scanner._parse_cvss_vector(None)
        self.assertIsNone(score)

    @patch("subprocess.run")
    def test_get_installed_packages(self, mock_run):
        """Test getting installed packages"""
        mock_run.return_value = MagicMock(
            returncode=0, stdout="package1|1.0.0\npackage2|2.0.0\npackage3|3.0.0\n"
        )

        packages = self.scanner._get_installed_packages()

        self.assertEqual(len(packages), 3)
        self.assertEqual(packages["package1"], "1.0.0")
        self.assertEqual(packages["package2"], "2.0.0")

    def test_cache_save_and_check(self):
        """Test saving and retrieving from cache"""
        vuln = Vulnerability(
            cve_id="CVE-2023-12345",
            package_name="test-pkg",
            installed_version="1.0.0",
            affected_versions="< 2.0.0",
            severity=Severity.HIGH,
            description="Test vulnerability",
        )

        # Save to cache
        self.scanner._save_cache("test-pkg", "1.0.0", [vuln])

        # Check cache
        cached = self.scanner._check_cache("test-pkg", "1.0.0")

        self.assertIsNotNone(cached)
        self.assertEqual(len(cached), 1)
        self.assertEqual(cached[0].cve_id, "CVE-2023-12345")
        self.assertEqual(cached[0].severity, Severity.HIGH)

    def test_cache_returns_none_for_uncached(self):
        """Test cache returns None for uncached packages"""
        cached = self.scanner._check_cache("nonexistent-pkg", "1.0.0")
        self.assertIsNone(cached)

    def test_save_scan_history(self):
        """Test saving scan history"""
        result = ScanResult(
            scan_id="test_scan_123",
            timestamp=datetime.now().isoformat(),
            total_packages_scanned=10,
            vulnerabilities_found=2,
            critical_count=1,
            high_count=1,
            medium_count=0,
            low_count=0,
            vulnerabilities=[],
            scan_duration_seconds=5.0,
        )

        self.scanner._save_scan_history(result)

        # Retrieve history
        history = self.scanner.get_scan_history(limit=1)

        self.assertEqual(len(history), 1)
        self.assertEqual(history[0].scan_id, "test_scan_123")

    def test_get_scan_history_empty(self):
        """Test getting empty scan history"""
        history = self.scanner.get_scan_history(limit=10)
        self.assertEqual(len(history), 0)

    def test_get_critical_vulnerabilities(self):
        """Test getting critical vulnerabilities from history"""
        # Create and save a scan with critical vulnerability
        critical_vuln = Vulnerability(
            cve_id="CVE-CRITICAL",
            package_name="test-pkg",
            installed_version="1.0",
            affected_versions="all",
            severity=Severity.CRITICAL,
            description="Critical vulnerability",
        )

        high_vuln = Vulnerability(
            cve_id="CVE-HIGH",
            package_name="test-pkg",
            installed_version="1.0",
            affected_versions="all",
            severity=Severity.HIGH,
            description="High vulnerability",
        )

        result = ScanResult(
            scan_id="test_critical",
            timestamp=datetime.now().isoformat(),
            total_packages_scanned=1,
            vulnerabilities_found=2,
            critical_count=1,
            high_count=1,
            medium_count=0,
            low_count=0,
            vulnerabilities=[critical_vuln, high_vuln],
            scan_duration_seconds=1.0,
        )

        self.scanner._save_scan_history(result)

        # Get critical vulnerabilities
        critical = self.scanner.get_critical_vulnerabilities(days=30)

        self.assertEqual(len(critical), 1)
        self.assertEqual(critical[0].cve_id, "CVE-CRITICAL")
        self.assertEqual(critical[0].severity, Severity.CRITICAL)

    @patch("requests.post")
    def test_query_osv_success(self, mock_post):
        """Test successful OSV query"""
        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "vulns": [
                {
                    "id": "CVE-2023-12345",
                    "summary": "Test vulnerability",
                    "severity": [{"type": "CVSS_V3", "score": 7.5}],
                }
            ]
        }
        mock_post.return_value = mock_response

        vulns = self.scanner._query_osv("test-pkg", "1.0.0")

        self.assertEqual(len(vulns), 1)
        self.assertEqual(vulns[0].cve_id, "CVE-2023-12345")

    @patch("requests.post")
    def test_query_osv_no_vulns(self, mock_post):
        """Test OSV query with no vulnerabilities"""
        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {}
        mock_post.return_value = mock_response

        vulns = self.scanner._query_osv("safe-pkg", "1.0.0")

        self.assertEqual(len(vulns), 0)

    @patch("requests.post")
    def test_query_osv_network_error(self, mock_post):
        """Test OSV query handles network errors"""
        import requests

        mock_post.side_effect = requests.RequestException("Network error")

        vulns = self.scanner._query_osv("test-pkg", "1.0.0")

        self.assertEqual(len(vulns), 0)  # Should return empty list on error

    @patch.object(VulnerabilityScanner, "_check_cache")
    @patch.object(VulnerabilityScanner, "_query_osv")
    def test_scan_package_uses_cache(self, mock_query, mock_cache):
        """Test scan_package uses cache when available"""
        cached_vuln = Vulnerability(
            cve_id="CVE-CACHED",
            package_name="test-pkg",
            installed_version="1.0",
            affected_versions="all",
            severity=Severity.MEDIUM,
            description="Cached vulnerability",
        )
        mock_cache.return_value = [cached_vuln]

        vulns = self.scanner.scan_package("test-pkg", "1.0")

        self.assertEqual(len(vulns), 1)
        self.assertEqual(vulns[0].cve_id, "CVE-CACHED")
        mock_query.assert_not_called()  # Should not query if cached

    @patch.object(VulnerabilityScanner, "_check_cache")
    @patch.object(VulnerabilityScanner, "_query_osv")
    @patch.object(VulnerabilityScanner, "_save_cache")
    def test_scan_package_queries_when_not_cached(self, mock_save, mock_query, mock_cache):
        """Test scan_package queries API when not cached"""
        mock_cache.return_value = None
        mock_query.return_value = [
            Vulnerability(
                cve_id="CVE-NEW",
                package_name="test-pkg",
                installed_version="1.0",
                affected_versions="all",
                severity=Severity.HIGH,
                description="New vulnerability",
            )
        ]

        vulns = self.scanner.scan_package("test-pkg", "1.0")

        self.assertEqual(len(vulns), 1)
        mock_query.assert_called_once()
        mock_save.assert_called_once()


class TestVulnerabilityScannerRateLimiting(unittest.TestCase):
    """Test rate limiting functionality"""

    def setUp(self):
        self.temp_db = tempfile.NamedTemporaryFile(delete=False, suffix=".db")
        self.temp_db.close()
        self.scanner = VulnerabilityScanner(db_path=self.temp_db.name)

    def tearDown(self):
        if os.path.exists(self.temp_db.name):
            os.unlink(self.temp_db.name)

    def test_rate_limit_enforces_delay(self):
        """Test rate limiting enforces minimum delay"""
        import time

        self.scanner.min_api_interval = 0.1  # 100ms for testing
        self.scanner.last_api_call = time.time()

        start = time.time()
        self.scanner._rate_limit()
        elapsed = time.time() - start

        # Should have waited at least some time
        self.assertGreaterEqual(elapsed, 0.05)


if __name__ == "__main__":
    unittest.main()

